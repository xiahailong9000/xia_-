<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>C++ TCP 消息群发_服务器</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type>
<META name=GENERATOR content="MSHTML 11.00.9600.18125"><LINK rel=stylesheet 
href="_template.css"></HEAD>
<BODY>
<DIV id=nsbanner>
<DIV id=bannerrow1>
<TABLE class=bannerparthead>
  <TBODY>
  <TR id=hdr>
    <TD class=runninghead noWrap><FONT 
size=3></FONT></TD></TR></TBODY></TABLE></DIV><FONT size=3></DIV>
<DIV id=nstext>
<P><FONT color=#ff0000>//【服务端】基于TCP，多线程的聊天框架代码&nbsp;C++TcpServer.h 
=======================</FONT><BR>class C_客户对象 
{<BR>public:<BR>&nbsp;SOCKET&nbsp; x连接套接字;<BR>&nbsp;sockaddr_in 
x客户地址;<BR>&nbsp;char&nbsp; x接收的消息[2048];<BR>&nbsp;int&nbsp; 
x消息长度,x发送的长度,x剩余长度,x累计长度;<BR>&nbsp;C_客户对象();<BR>&nbsp;C_客户对象(LPVOID&nbsp; 
x连接);<BR>&nbsp;~C_客户对象();<BR>&nbsp;int&nbsp; S_接收消息();<BR>&nbsp;int S_发送消息(char 
x消息[]);<BR>&nbsp;int S_群发消息(char x消息[]);<BR>private:<BR>};</P>
<P>&nbsp;</P>
<P><FONT color=#ff0000>//【服务端】基于TCP，多线程的聊天框架代码&nbsp;C++TcpServer.cpp 
=====================</FONT><BR>#define _CRT_SECURE_NO_DEPRECATE<BR>#define 
_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1<BR>#include 
&lt;stdio.h&gt;<BR>#include &lt;winsock2.h&gt;<BR>#include 
&lt;map&gt;<BR>#include "C++TcpServer.h"&nbsp; 
//脚本名-----------------------<BR>#pragma comment(lib,"ws2_32.lib")<BR>using 
namespace std;<BR>map&lt;sockaddr_in*,C_客户对象*&gt; 
o_客户端列表;<BR>map&lt;sockaddr_in*,C_客户对象*&gt;::iterator o_it;<BR>typedef struct 
M_mm {<BR>&nbsp;SOCKET v套接字;<BR>&nbsp;sockaddr_in *v地址;<BR>&nbsp;string 
ip;<BR>&nbsp;M_mm(SOCKET v套接字0,sockaddr_in *v地址0) 
{<BR>&nbsp;&nbsp;v套接字=v套接字0;<BR>&nbsp;&nbsp;v地址=v地址0;<BR>&nbsp;}<BR>};<BR>C_客户对象::C_客户对象() 
{}<BR>C_客户对象::C_客户对象(LPVOID&nbsp; x结构) 
{<BR>&nbsp;o_客户端列表[&amp;x客户地址]=(C_客户对象*)this;<BR>&nbsp;M_mm 
*omm=(M_mm*)x结构;<BR>&nbsp;x连接套接字=M_mm(*omm).v套接字;<BR>&nbsp;x客户地址=sockaddr_in(*M_mm(*omm).v地址);<BR>&nbsp;printf("%s:%d连接到了本服务------对象地址%x-------.\n",inet_ntoa(x客户地址.sin_addr),ntohs(x客户地址.sin_port),(C_客户对象*)this);<BR>&nbsp;S_接收消息();<BR>}<BR>C_客户对象::~C_客户对象() 
{<BR>&nbsp;closesocket(x连接套接字);<BR>&nbsp;o_it=o_客户端列表.find(&amp;x客户地址);<BR>&nbsp;if(o_it==o_客户端列表.end()) 
{<BR>&nbsp;&nbsp;printf("%s:%d已退出,但客户列表出错------对象地址%x-------.\n",inet_ntoa(x客户地址.sin_addr),ntohs(x客户地址.sin_port),(C_客户对象*)this);<BR>&nbsp;} 
else 
{<BR>&nbsp;&nbsp;o_客户端列表.erase(o_it);<BR>&nbsp;&nbsp;printf("%s:%d已退出,并以断开连接------对象地址%x-------.\n",inet_ntoa(x客户地址.sin_addr),ntohs(x客户地址.sin_port),(C_客户对象*)this);<BR>&nbsp;}<BR>}<BR>int 
C_客户对象::S_接收消息() {<BR>&nbsp;while(1) 
{<BR>&nbsp;&nbsp;memset(x接收的消息,0x00,sizeof(x接收的消息));<BR>&nbsp;&nbsp;x消息长度=recv(x连接套接字,x接收的消息,2048,0);<BR>&nbsp;&nbsp;if(x消息长度==0) 
{<BR>&nbsp;&nbsp;&nbsp;printf("接收消息出错，长度为0\n");<BR>&nbsp;&nbsp;&nbsp;return 
0;<BR>&nbsp;&nbsp;} else if(x消息长度==SOCKET_ERROR) 
{<BR>&nbsp;&nbsp;&nbsp;printf("接收消息出错，长度为-1&nbsp;&nbsp; 
failed:%d\n",WSAGetLastError());<BR>&nbsp;&nbsp;&nbsp;return 
0;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;x接收的消息[x消息长度]='\0';<BR>&nbsp;&nbsp;S_群发消息(x接收的消息);<BR>&nbsp;}<BR>&nbsp;return 
1;<BR>}<BR>int C_客户对象::S_发送消息(char x消息[]) 
{<BR>&nbsp;x剩余长度=strlen(x消息);&nbsp;//字符 
串长度----<BR>&nbsp;x累计长度=0;<BR>&nbsp;while(x剩余长度&gt;0) 
{<BR>&nbsp;&nbsp;x发送的长度=send(x连接套接字,&amp;x消息[x累计长度],x剩余长度,0);<BR>&nbsp;&nbsp;if(x发送的长度==0) 
{<BR>&nbsp;&nbsp;&nbsp;printf("发送出错，发送的消息长度为0");<BR>&nbsp;&nbsp;&nbsp;return 
0;<BR>&nbsp;&nbsp;} else if(x发送的长度==SOCKET_ERROR) 
{<BR>&nbsp;&nbsp;&nbsp;printf("发送出错, 发送的长度为-1 , 
%d\n",WSAGetLastError());<BR>&nbsp;&nbsp;&nbsp;return 
0;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;x剩余长度-=x发送的长度;<BR>&nbsp;&nbsp;x累计长度+=x发送的长度;<BR>&nbsp;}<BR>&nbsp;printf("\n消息发送成功：%s\n",x消息);<BR>&nbsp;return 
1;<BR>}<BR>int C_客户对象::S_群发消息(char x消息[]) {<BR>&nbsp;try 
{<BR>&nbsp;&nbsp;for(map&lt;sockaddr_in*,C_客户对象*&gt;::iterator 
it=o_客户端列表.begin(); it!=o_客户端列表.end(); it++) {&nbsp; 
//遍历<BR>&nbsp;&nbsp;&nbsp;printf("群发消息 端口:%d&nbsp; 
对象地址%x\n",ntohs((*it-&gt;first).sin_port),(*it-&gt;second));<BR>&nbsp;&nbsp;&nbsp;(*it-&gt;second).S_发送消息(x消息);<BR>&nbsp;&nbsp;}<BR>&nbsp;} 
catch(double) 
{<BR>&nbsp;&nbsp;printf("遍历群发消息出错-----------------\n");<BR>&nbsp;}<BR>&nbsp;return 
1;<BR>}<BR>DWORD WINAPI th_ClientThread(LPVOID x结构) {<BR>&nbsp;C_客户对象 
cc=C_客户对象(x结构);<BR>&nbsp;return 0;<BR>}<BR>DWORD WINAPI th_启动监听(LPVOID dd) 
{<BR>&nbsp; WSADATA&nbsp; wsd;//定义WINSOCK32消息结构体<BR>&nbsp; SOCKET&nbsp; 
o_监听套接字,o_连接套接字;<BR>&nbsp; HANDLE&nbsp; o_Thread;//定义处理客户连接的县城<BR>&nbsp; 
DWORD&nbsp; dwThreadId;//定义线程ID<BR>&nbsp; sockaddr_in 
x本机地址,x客户地址;//分别定义本地，客户端的地址结构<BR>&nbsp; int 
o_客户地址长度=sizeof(x客户地址);//得到地址结构长度</P>
<P>&nbsp; //初始化Winsock32库<BR>&nbsp; if(WSAStartup(MAKEWORD(2,2),&amp;wsd)!=0) 
{<BR>&nbsp;&nbsp; printf("没有加载Winsock！\n");<BR>&nbsp;&nbsp;// return 
1;<BR>&nbsp; }<BR>&nbsp; 
if((o_监听套接字=socket(AF_INET,SOCK_STREAM,IPPROTO_IP))==INVALID_SOCKET) 
{//创建服务器监听套接字<BR>&nbsp;&nbsp; printf("创建监听套接字失败");<BR>&nbsp; }<BR>&nbsp; 
x本机地址.sin_family=AF_INET;<BR>&nbsp; x本机地址.sin_port=htons(5000);//监听端口<BR>&nbsp; 
x本机地址.sin_addr.s_addr=htonl(INADDR_ANY);&nbsp; //地址</P>
<P>&nbsp; if(bind(o_监听套接字,(LPSOCKADDR)&amp;x本机地址,sizeof(x本机地址))==SOCKET_ERROR) 
{//将套接字绑定到本机地址上-----------------------------<BR>&nbsp;&nbsp; printf("绑定出错 
error:%d!\n",WSAGetLastError());<BR>&nbsp;&nbsp;// return 1;<BR>&nbsp; 
}<BR>&nbsp; if(listen(o_监听套接字,5)==SOCKET_ERROR) 
{//监听客户连接请求-----------------------------------------------<BR>&nbsp;&nbsp; 
printf("监听出错 error:%d\n",WSAGetLastError());<BR>&nbsp;&nbsp; //return 
1;<BR>&nbsp; }<BR>&nbsp; 
printf("服务器正在监听---------------------------\n");<BR>&nbsp; while(1) 
{<BR>&nbsp;&nbsp; o_连接套接字=accept(o_监听套接字,(struct sockaddr 
*)&amp;x客户地址,&amp;o_客户地址长度);&nbsp; //通过监听套接字创建连接套接字&nbsp; <BR>&nbsp;&nbsp; 
if(o_连接套接字==INVALID_SOCKET) {<BR>&nbsp;&nbsp;&nbsp; printf("创建链接套接字失败 error 
%d\n",WSAGetLastError());<BR>&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp; M_mm x结构=M_mm(o_连接套接字,&amp;x客户地址);<BR>&nbsp;&nbsp; 
o_Thread=CreateThread(NULL,0,th_ClientThread,(LPVOID)&amp;x结构,0,&amp;dwThreadId);<BR>&nbsp;&nbsp; 
if(o_Thread==NULL) {<BR>&nbsp;&nbsp;&nbsp; printf("创建线程失败 failed 
%d\n",GetLastError());<BR>&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp; CloseHandle(o_Thread); //聊天结束关闭聊天线程，继续监听<BR>&nbsp; }<BR>&nbsp; 
closesocket(o_监听套接字);<BR>&nbsp; WSACleanup();<BR>&nbsp; return 0;<BR>}<BR>void 
S_启动监听服务器() {<BR>&nbsp;HANDLE 
th=CreateThread(NULL,0,th_启动监听,NULL,0,NULL);<BR>&nbsp;CloseHandle(th);<BR>}</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><FONT color=#ff0000>//程序入口&nbsp;main.cpp 
=========================</FONT><BR>#include &lt;stdio.h&gt;<BR>void 
S_启动监听服务器();</P>
<P>void main() {<BR>&nbsp;&nbsp;&nbsp; S_启动监听服务器();</P>
<P>&nbsp;printf("主线程处于空闲状态――――――――\n");<BR>&nbsp;while (true){}<BR>}</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><FONT color=#ff0000>//====================u3d 
客户端==============================</FONT></P>
<P>using System;<BR>using System.Net.Sockets;<BR>using UnityEngine;<BR>public 
class C_tcp:MonoBehaviour {<BR>&nbsp;&nbsp;&nbsp; private TcpClient 
o_客户端实体;<BR>&nbsp;&nbsp;&nbsp; byte[] o_消息数据;<BR>&nbsp;&nbsp;&nbsp; public 
string o_接收字符串;<BR>&nbsp;&nbsp;&nbsp; public string 
sendMsg="ddddddd哈哈哈哈哈ffffffffffffffwwwwwwwwwwww";<BR>&nbsp;&nbsp;&nbsp; public 
string ip="127.0.0.1";<BR>&nbsp;&nbsp;&nbsp; public int 
o_端口=5000;<BR>&nbsp;&nbsp;&nbsp; void Start() 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Screen.SetResolution(320,260,false,0);<BR>&nbsp;&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp;&nbsp; void OnGUI() 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUI.Label(new 
Rect(10,5,40,20),"ip地址");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
ip=GUI.TextField(new Rect(60,5,120,20),ip);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUI.Label(new 
Rect(190,5,40,20),"端口");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
o_端口=int.Parse(GUI.TextField(new Rect(220,5,90,20),o_端口.ToString()));</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o_接收字符串=GUI.TextArea(new 
Rect(10,30,300,200),o_接收字符串);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendMsg=GUI.TextField(new 
Rect(10,235,250,20),sendMsg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
if(GUI.Button(new Rect(265,235,45,20),"发送")) 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
s_发送消息(sendMsg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
};<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; void S_建立连接() 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o_客户端实体=new 
TcpClient(ip,o_端口);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o_消息数据=new 
byte[this.o_客户端实体.ReceiveBufferSize];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
this.o_客户端实体.GetStream().BeginRead(o_消息数据,0,System.Convert.ToInt32(this.o_客户端实体.ReceiveBufferSize),s_接收消息,null);<BR>&nbsp;&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp;&nbsp; public void s_发送消息(string message) 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(o_客户端实体==null) 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
S_建立连接();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
NetworkStream 
ns=this.o_客户端实体.GetStream();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
byte[] 
data=System.Text.Encoding.UTF8.GetBytes(message);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
ns.Write(data,0,data.Length);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
ns.Flush();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch(Exception ex) 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
print(ex.Message);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; public void s_接收消息(IAsyncResult 
ar) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 
o_消息字节长度=0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
o_消息字节长度=this.o_客户端实体.GetStream().EndRead(ar);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
if(o_消息字节长度&lt;1) 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
else 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Debug.Log(System.Text.Encoding.UTF8.GetString(o_消息数据,0,o_消息字节长度));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
o_接收字符串+=System.Text.Encoding.UTF8.GetString(o_消息数据,0,o_消息字节长度)+"\n";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
if(o_接收字符串.Length&gt;250) 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
o_接收字符串=o_接收字符串.Remove(0,o_接收字符串.Length-250);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
this.o_客户端实体.GetStream().BeginRead(o_消息数据,0,System.Convert.ToInt32(this.o_客户端实体.ReceiveBufferSize),s_接收消息,null);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
} catch(Exception ex) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><FONT 
color=#ff0000>//=====================C++客户端==========================</FONT></P>
<P>#include &lt;iostream&gt;<BR>#include &lt;winsock2.h&gt; 
<BR>#include&lt;stdio.h&gt;<BR>#pragma comment(lib,"ws2_32.lib")&nbsp;&nbsp; 
<BR>using namespace std;</P>
<P>class C_TCPclient{<BR>public:<BR>&nbsp;string o_ip="127.0.0.1";<BR>&nbsp;int 
o_port=5000;<BR>&nbsp;SOCKET o_客户端实体;<BR>&nbsp;SOCKADDR_IN 
x本机地址;<BR>&nbsp;WSADATA wsaData;<BR>&nbsp;char 
buff[1024];<BR>public:&nbsp;<BR>&nbsp;C_TCPclient();<BR>&nbsp;void S_发送消息(string 
x消息);<BR>&nbsp;static DWORD&nbsp; S_接收消息(LPVOID 
dd);<BR>&nbsp;~C_TCPclient();<BR>private:<BR>};<BR>C_TCPclient::C_TCPclient(){<BR>&nbsp;memset(buff,0,sizeof(buff));<BR>&nbsp;if(WSAStartup(MAKEWORD(2,2),&amp;wsaData)!=0) 
{<BR>&nbsp;&nbsp;printf("未能加载Winsock");<BR>&nbsp;&nbsp;return;<BR>&nbsp;}<BR>&nbsp;x本机地址.sin_family=AF_INET;<BR>&nbsp;x本机地址.sin_port=htons(o_port);<BR>&nbsp;x本机地址.sin_addr.S_un.S_addr=inet_addr(o_ip.c_str()); 
</P>
<P>&nbsp;&nbsp;&nbsp; 
o_客户端实体=socket(AF_INET,SOCK_STREAM,0);<BR>&nbsp;if(SOCKET_ERROR==o_客户端实体) 
{<BR>&nbsp;&nbsp;printf("Socket() 
error:%d",WSAGetLastError());<BR>&nbsp;&nbsp;return;<BR>&nbsp;}<BR>&nbsp;//向服务器发出连接请求&nbsp; 
<BR>&nbsp;if(connect(o_客户端实体,(struct&nbsp; 
sockaddr*)&amp;x本机地址,sizeof(x本机地址))==INVALID_SOCKET) 
{<BR>&nbsp;&nbsp;printf("Connect 
failed:%d",WSAGetLastError());<BR>&nbsp;&nbsp;return;<BR>&nbsp;} else 
{<BR>&nbsp;&nbsp;HANDLE 
th=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)S_接收消息,this,0,NULL);<BR>&nbsp;//&nbsp;CloseHandle(th);<BR>&nbsp;}<BR>}<BR>C_TCPclient::~C_TCPclient(){<BR>&nbsp;closesocket(o_客户端实体);<BR>&nbsp;WSACleanup();<BR>}<BR>DWORD&nbsp; 
C_TCPclient::S_接收消息(LPVOID dd) {<BR>&nbsp;C_TCPclient 
*cc=(C_TCPclient*)dd;<BR>&nbsp;char x接收的消息[1024];<BR>&nbsp;while(true) 
{<BR>&nbsp;&nbsp;int 
x消息长度=recv(cc-&gt;o_客户端实体,x接收的消息,sizeof(x接收的消息),0);<BR>&nbsp;&nbsp;x接收的消息[x消息长度]='\0';<BR>&nbsp;&nbsp;printf("%s\n",x接收的消息);<BR>&nbsp;}<BR>&nbsp;return 
0;<BR>}<BR>void C_TCPclient::S_发送消息(string x消息) 
{<BR>&nbsp;printf("发送长度======================%d\n",x消息.length());<BR>&nbsp;send(o_客户端实体,x消息.c_str(),strlen(x消息.c_str()),0);<BR>//&nbsp;send(o_客户端实体,x消息.c_str(),x消息.length(),0);<BR>}<BR>int 
main() {<BR>&nbsp;C_TCPclient 
cc=C_TCPclient();<BR>&nbsp;cc.S_发送消息("fffffffffffffffffff");<BR>&nbsp;Sleep(2000);<BR>&nbsp;cc.S_发送消息("说的是是是是是是是是是是");<BR>&nbsp;Sleep(2000);<BR>&nbsp;cc.S_发送消息("是的是的是的s");<BR>&nbsp;while(true) 
{}<BR>&nbsp;return 0;<BR>}<BR></P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P></FONT>&nbsp;</P></DIV></BODY></HTML>
